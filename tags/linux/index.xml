<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>linux on SixSixtySix Corp.</title><link>https://6sixty6.github.io/tags/linux/</link><description>Recent content in linux on SixSixtySix Corp.</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 19 Feb 2022 21:50:00 +0000</lastBuildDate><atom:link href="https://6sixty6.github.io/tags/linux/index.xml" rel="self" type="application/rss+xml"/><item><title>Dirty COW (CVE-2016-5195)</title><link>https://6sixty6.github.io/posts/2022-02-19-dirty-cow/</link><pubDate>Sat, 19 Feb 2022 21:50:00 +0000</pubDate><guid>https://6sixty6.github.io/posts/2022-02-19-dirty-cow/</guid><description>author:[anusO1] COW (Copy on Write) Copy on Write is an optimization technique that allows virtual pages of memory in different processes, which have identical content to map to the same physical memory pages. If one of the processes writes to one of these shared pages, the data is copied to a new physical page and the virtual-to-physical-memory mappings are updated according to the changes. This techniqie is used (and abused) in many different scenarios.</description></item><item><title>CVE-2022-25265 - Executable Space Protection Bypass</title><link>https://6sixty6.github.io/posts/2022-02-19-cve-2022-25265-executable-space-protection-bypass/</link><pubDate>Sat, 19 Feb 2022 09:00:00 +0000</pubDate><guid>https://6sixty6.github.io/posts/2022-02-19-cve-2022-25265-executable-space-protection-bypass/</guid><description>author:[xoreaxeax] As it turns out, binary files built either under old Linux systems lacking NX or IA32 systems with NX,
which do NOT create PT_GNU_STACK header will be marked and treated with exec-all personality flag by the Linux kernel.
This allows for read/write/exec of bytes located in supposedly non-executable and non-writable regions of binary files, therefore completely bypassing executable-space protection.
The flawed implementation can be found here: https://github.com/torvalds/linux/blob/master/arch/x86/include/asm/elf.h#L280
To achieve this, &amp;ldquo;historical&amp;rdquo; building tools will be used for building the binary.</description></item><item><title>gcc Silent Trampoline Execstack Abuse</title><link>https://6sixty6.github.io/posts/2022-02-19-gcc-silent-trampoline-execstack-abuse/</link><pubDate>Sat, 19 Feb 2022 09:00:00 +0000</pubDate><guid>https://6sixty6.github.io/posts/2022-02-19-gcc-silent-trampoline-execstack-abuse/</guid><description>author:[xoreaxeax] Danger by design of GNU&amp;rsquo;s GCC nested functions raises from use of trampolines - small pieces of code used to implement pointers to nested functions.
These trampolines are created on stack, meaning the stack needs to be marked as executable for nested functions to be executed - the nested function pointer is after all the address of the trampoline itself.
Executable stack is heavily frowned upon on modern systems. In this case however, the bigger problem arises from the stack being set to RWE (Read/Write/Execute) silently, without any warning message during compilation and linking.</description></item></channel></rss>